"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-range-slider-input";
exports.ids = ["vendor-chunks/react-range-slider-input"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-range-slider-input/dist/components/RangeSlider.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-range-slider-input/dist/components/RangeSlider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"(ssr)/./node_modules/core-js/modules/es.parse-float.js\");\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.m.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n// Aliases\nconst abs = Math.abs;\nconst float = parseFloat; // Values\n\nconst MIN = 'min';\nconst MAX = 'max';\nconst ANY = 'any';\nconst VERTICAL = 'vertical';\nconst TABINDEX = 'tabindex'; // Data Attributes\n\nconst DATA_LOWER = 'data-lower';\nconst DATA_UPPER = 'data-upper';\nconst DATA_ACTIVE = 'data-active';\nconst DATA_VERTICAL = 'data-vertical';\nconst DATA_DISABLED = 'data-disabled';\n\nclass RangeSlider extends _react.PureComponent {\n  constructor() {\n    super();\n    this.element = /*#__PURE__*/(0, _react.createRef)();\n    this.input = [/*#__PURE__*/(0, _react.createRef)(), /*#__PURE__*/(0, _react.createRef)()];\n    this.thumb = [/*#__PURE__*/(0, _react.createRef)(), /*#__PURE__*/(0, _react.createRef)()];\n    this.range = /*#__PURE__*/(0, _react.createRef)();\n    this.options = {};\n    this.firstCall = true;\n    this.isControlled = false;\n    this.externalInput = false;\n    this.isComponentMounted = false;\n    this.lastValueProp = [];\n  }\n\n  componentDidMount() {\n    if (!this.isComponentMounted) {\n      this.value = this.setMinMaxProps(); // Thumb indexes for min and max values\n      // (swapped when the thumbs cross each other)\n\n      this.index = this.setMinMaxProps(0, 1); // Thumb width & height for calculation of exact positions and sizes of horizontal thumbs and range\n\n      this.thumbWidth = this.setMinMaxProps();\n      this.thumbHeight = this.setMinMaxProps(); // Slidable range limits (when a thumb is dragged)\n\n      this.rangeLimits = this.setMinMaxProps(); // Slider value depending on the user interaction\n\n      this.sliderValue = this.setMinMaxProps(); // For dragging thumbs and range\n\n      this.maxRangeWidth = 0;\n      this.rangeWidth = 0;\n      this.isDragging = false;\n      this.thumbDrag = false;\n      this.startPos = 0; // initial\n\n      this.reset(); // Add listeners to element\n\n      this.addNodeEventListener(this.element.current, 'pointerdown', e => {\n        this.elementFocused(e);\n      }); // Add listeners to thumbs and set [data-disabled] on disabled thumbs\n\n      this.thumb.forEach((t, i) => {\n        this.addNodeEventListener(t.current, 'pointerdown', e => {\n          this.initiateThumbDrag(e, i, t.current);\n        });\n        this.addNodeEventListener(t.current, 'keydown', e => {\n          if (e.which >= 37 && e.which <= 40) {\n            e.preventDefault();\n            this.stepValue(i, e.which);\n          }\n        });\n      }); // Add listeners to range\n\n      this.addNodeEventListener(this.range.current, 'pointerdown', e => {\n        this.initiateRangeDrag(e);\n      }); // Define and add global listeners\n\n      this.pointerMoveEvent = e => {\n        this.drag(e);\n      };\n\n      this.pointerUpEvent = () => {\n        if (this.isDragging) {\n          this.removeNodeAttribute(this.thumb[0].current, DATA_ACTIVE);\n          this.removeNodeAttribute(this.thumb[1].current, DATA_ACTIVE);\n          this.removeNodeAttribute(this.range.current, DATA_ACTIVE);\n          this.isDragging = false;\n\n          if (this.thumbDrag) {\n            if (this.options.onThumbDragEnd) {\n              this.options.onThumbDragEnd();\n            }\n          } else {\n            if (this.options.onRangeDragEnd) {\n              this.options.onRangeDragEnd();\n            }\n          }\n        }\n      };\n\n      this.resizeEvent = () => {\n        this.syncThumbDimensions();\n        this.updateThumbs();\n        this.updateRange();\n      };\n\n      this.addNodeEventListener(document, 'pointermove', this.pointerMoveEvent);\n      this.addNodeEventListener(document, 'pointerup', this.pointerUpEvent);\n      this.addNodeEventListener(window, 'resize', this.resizeEvent);\n      this.isComponentMounted = true;\n    }\n  }\n\n  componentDidUpdate() {\n    this.reset();\n  }\n\n  componentWillUnmount() {\n    // Remove global listeners\n    this.removeNodeEventListener(document, 'pointermove', this.pointerMoveEvent);\n    this.removeNodeEventListener(document, 'pointerup', this.pointerUpEvent);\n    this.removeNodeEventListener(window, 'resize', this.resizeEvent);\n    this.isComponentMounted = false;\n  }\n\n  reset() {\n    this.isControlled = !!this.props.value;\n\n    if (this.isControlled) {\n      if (this.firstCall || this.props.value !== this.lastValueProp) {\n        this.firstCall = false;\n        this.externalInput = true;\n      }\n\n      this.lastValueProp = this.props.value;\n    }\n\n    this.maxRangeWidth = this.options.max - this.options.min;\n    this.updateOrientation();\n    this.setValue('', true, false);\n    this.updateRangeLimits();\n    this.updateDisabledState();\n    this.updateThumbsDisabledState();\n    this.updateTabIndexes();\n  }\n\n  isNumber(n) {\n    // check for NaN explicitly\n    // because with NaN, the second exp. evaluates to true\n    return !isNaN(n) && +n + '' === n + '';\n  }\n\n  setMinMaxProps() {\n    let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return {\n      min,\n      max\n    };\n  }\n\n  iterateMinMaxProps(fn) {\n    [MIN, MAX].forEach(fn);\n  }\n\n  getSetProps(condition, expression, fn) {\n    if (condition) {\n      return expression;\n    } else {\n      fn();\n    }\n  }\n\n  setNodeAttribute(node, attribute) {\n    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    node.setAttribute(attribute, value);\n  }\n\n  removeNodeAttribute(node, attribute) {\n    node.removeAttribute(attribute);\n  }\n\n  addNodeEventListener(node, event, fn) {\n    let isPointerEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    // with options for pointer events\n    node.addEventListener(event, fn, isPointerEvent ? {\n      passive: false,\n      capture: true\n    } : {});\n  }\n\n  removeNodeEventListener(node, event, fn) {\n    let isPointerEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    // with options for pointer events\n    node.removeEventListener(event, fn, isPointerEvent ? {\n      passive: false,\n      capture: true\n    } : {});\n  }\n\n  fallbackToDefault(property, defaultValue) {\n    this.options[property] = this.props[property] ? this.props[property] : defaultValue;\n  }\n\n  ifVerticalElse(vertical, horizontal) {\n    return this.options.orientation === VERTICAL ? vertical : horizontal;\n  }\n\n  currentIndex(i) {\n    return i === 1 ? this.index.max : this.index.min;\n  } // Set min and max values to 1 (arbitrarily) if any of the min or max values are \"invalid\"\n  // Setting both values 1 will disable the slider\n  // Called when,\n  // -> the element is initially set\n  // -> min or max properties are modified\n\n\n  safeMinMaxValues() {\n    let error = false;\n\n    if (!this.isNumber(this.options.min) || !this.isNumber(this.options.max)) {\n      error = true;\n    }\n\n    this.options.min = error ? 1 : +this.options.min;\n    this.options.max = error ? 1 : +this.options.max;\n  } // Reframe the thumbsDisabled value if \"invalid\"\n  // Called when,\n  // -> the element is initially set\n  // -> thumbsDisabled property is modified\n\n\n  safeThumbsDisabledValues() {\n    if (this.options.thumbsDisabled instanceof Array) {\n      if (this.options.thumbsDisabled.length === 1) {\n        this.options.thumbsDisabled.push(false);\n      }\n\n      if (this.options.thumbsDisabled.length !== 1 && this.options.thumbsDisabled.length !== 2) {\n        this.options.thumbsDisabled = [false, false];\n      }\n    } else {\n      this.options.thumbsDisabled = [this.options.thumbsDisabled, this.options.thumbsDisabled];\n    } // Boolean Values\n\n\n    this.options.thumbsDisabled[0] = !!this.options.thumbsDisabled[0];\n    this.options.thumbsDisabled[1] = !!this.options.thumbsDisabled[1];\n  } // Called when,\n  // -> the element is initially set\n  // -> min, max, step or value properties are modified\n  // -> thumbs are dragged\n  // -> element is clicked upon\n  // -> an arrow key is pressed\n\n\n  setValue(newValue) {\n    let forceSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Current value as set in the input elements\n    // which could change while changing min, max and step values\n    const currentValue = this.setMinMaxProps(this.input[0].current.value, this.input[1].current.value); // var value is synced with the values set in the input elements if no newValue is passed\n\n    newValue = newValue || currentValue;\n    this.input[this.index.min].current.value = newValue.min;\n    this.input[this.index.max].current.value = this.thumbDrag || forceSet ? newValue.max : newValue.min + this.rangeWidth;\n    this.syncValues(); // Check if the thumbs cross each other\n\n    if (this.value.min > this.value.max) {\n      // Switch thumb indexes\n      this.index.min = +!this.index.min;\n      this.index.max = +!this.index.max; // Switch thumb attributes\n\n      this.removeNodeAttribute(this.thumb[this.index.min].current, DATA_UPPER);\n      this.removeNodeAttribute(this.thumb[this.index.max].current, DATA_LOWER);\n      this.setNodeAttribute(this.thumb[this.index.min].current, DATA_LOWER);\n      this.setNodeAttribute(this.thumb[this.index.max].current, DATA_UPPER); // Switch thumb drag labels\n\n      if (this.thumbDrag) {\n        this.thumbDrag = this.thumbDrag === MIN ? MAX : MIN;\n      }\n\n      this.syncValues();\n    }\n\n    this.sliderValue = forceSet ? this.value : newValue;\n    let valueSet = false;\n\n    if (currentValue.min !== this.input[0].current.value || forceSet) {\n      valueSet = true;\n    }\n\n    if (currentValue.max !== this.input[1].current.value || forceSet) {\n      valueSet = true;\n    } // Update the positions, dimensions and aria attributes everytime a value is set\n    // and call the onInput function from options (if set)\n\n\n    if (valueSet) {\n      if (callback && this.options.onInput) {\n        this.options.onInput([this.value.min, this.value.max]);\n      }\n\n      if (!this.isControlled || this.externalInput) {\n        this.externalInput = false;\n        this.syncThumbDimensions();\n        this.updateThumbs();\n        this.updateRange();\n        this.updateAriaValueAttributes();\n      }\n    }\n  } // Sync var value with the input elements\n\n\n  syncValues() {\n    this.iterateMinMaxProps(_ => {\n      this.value[_] = +this.input[this.index[_]].current.value;\n    });\n  } // Called when,\n  // -> setValue is called and a value is set\n  // -> window is resized\n\n\n  updateThumbs() {\n    this.iterateMinMaxProps(_ => {\n      this.thumb[this.index[_]].current.style[this.ifVerticalElse('top', 'left')] = \"calc(\".concat((this.value[_] - this.options.min) / this.maxRangeWidth * 100, \"% + \").concat((0.5 - (this.value[_] - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth)[_], \"px)\");\n    });\n  } // Called when,\n  // -> setValue is called and a value is set\n  // -> window is resized\n\n\n  updateRange() {\n    const elementBounds = this.element.current.getBoundingClientRect();\n    const deltaOffset = (0.5 - (this.value.min - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth).min / this.ifVerticalElse(elementBounds.bottom - elementBounds.top, elementBounds.right - elementBounds.left);\n    const deltaDimension = (0.5 - (this.value.max - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth).max / this.ifVerticalElse(elementBounds.bottom - elementBounds.top, elementBounds.right - elementBounds.left);\n    this.range.current.style[this.ifVerticalElse('top', 'left')] = \"\".concat(((this.value.min - this.options.min) / this.maxRangeWidth + deltaOffset) * 100, \"%\");\n    this.range.current.style[this.ifVerticalElse('height', 'width')] = \"\".concat(((this.value.max - this.options.min) / this.maxRangeWidth - (this.value.min - this.options.min) / this.maxRangeWidth - deltaOffset + deltaDimension) * 100, \"%\");\n  }\n\n  updateRangeLimits() {\n    this.iterateMinMaxProps((_, i) => {\n      this.rangeLimits[_] = this.options.thumbsDisabled[i] ? this.value[_] : this.options[_];\n    });\n  } // Called when,\n  // -> thumbs are initially set\n  // -> thumbs are disabled / enabled\n\n\n  updateTabIndexes() {\n    this.iterateMinMaxProps((_, i) => {\n      if (!this.options.disabled && !this.options.thumbsDisabled[i]) {\n        this.setNodeAttribute(this.thumb[this.currentIndex(i)].current, TABINDEX, 0);\n      } else {\n        this.removeNodeAttribute(this.thumb[this.currentIndex(i)].current, TABINDEX);\n      }\n    });\n  } // Called when,\n  // -> setValue is called and a value is set\n\n\n  updateAriaValueAttributes() {\n    this.iterateMinMaxProps(_ => {\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuemin', this.options.min);\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuemax', this.options.max);\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuenow', this.value[_]);\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuetext', this.value[_]);\n    });\n  } // Called when,\n  // -> disabled property is modified\n\n\n  updateDisabledState() {\n    if (this.options.disabled) {\n      this.setNodeAttribute(this.element.current, DATA_DISABLED);\n    } else {\n      this.removeNodeAttribute(this.element.current, DATA_DISABLED);\n    }\n  } // Called when,\n  // -> thumbsDisabled property is modified\n\n\n  updateThumbsDisabledState() {\n    this.options.thumbsDisabled.forEach((d, i) => {\n      const currIndex = this.currentIndex(i);\n\n      if (d) {\n        this.setNodeAttribute(this.thumb[currIndex].current, DATA_DISABLED);\n        this.setNodeAttribute(this.thumb[currIndex].current, 'aria-disabled', true);\n      } else {\n        this.removeNodeAttribute(this.thumb[currIndex].current, DATA_DISABLED);\n        this.setNodeAttribute(this.thumb[currIndex].current, 'aria-disabled', false);\n      }\n    });\n  } // Called when,\n  // -> min or max values are modified\n\n\n  updateLimits(limit) {\n    let m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.options[limit] = m;\n    this.safeMinMaxValues();\n    this.iterateMinMaxProps(_ => {\n      this.input[0].current[_] = this.options[_];\n      this.input[1].current[_] = this.options[_];\n    });\n    this.maxRangeWidth = this.options.max - this.options.min;\n    this.setValue('', true);\n    this.updateRangeLimits();\n  } // Called when,\n  // -> the element is initially set\n  // -> orientation property is modified\n\n\n  updateOrientation() {\n    if (this.options.orientation === VERTICAL) {\n      this.setNodeAttribute(this.element.current, DATA_VERTICAL);\n    } else {\n      this.removeNodeAttribute(this.element.current, DATA_VERTICAL);\n    }\n\n    this.range.current.style[this.ifVerticalElse('left', 'top')] = '';\n    this.range.current.style[this.ifVerticalElse('width', 'height')] = '';\n    this.thumb[0].current.style[this.ifVerticalElse('left', 'top')] = '';\n    this.thumb[1].current.style[this.ifVerticalElse('left', 'top')] = '';\n  } // thumb width & height values are to be synced with the CSS values for correct calculation of\n  // thumb position and range width & position\n  // Called when,\n  // -> setValue is called and a value is set (called before updateThumbs() and updateRange())\n  // -> thumb / range drag is initiated\n  // -> window is resized\n\n\n  syncThumbDimensions() {\n    this.iterateMinMaxProps(_ => {\n      this.thumbWidth[_] = float(window.getComputedStyle(this.thumb[this.index[_]].current).width);\n      this.thumbHeight[_] = float(window.getComputedStyle(this.thumb[this.index[_]].current).height);\n    });\n  } // thumb position calculation depending upon the pointer position\n\n\n  currentPosition(e, node) {\n    const elementBounds = this.element.current.getBoundingClientRect();\n    const nodeBounds = node.getBoundingClientRect();\n    const currPos = (this.ifVerticalElse(nodeBounds.top - elementBounds.top, nodeBounds.left - elementBounds.left) + (e[\"client\".concat(this.ifVerticalElse('Y', 'X'))] - node.getBoundingClientRect()[this.ifVerticalElse('top', 'left')]) - (this.thumbDrag ? (0.5 - (this.value[this.thumbDrag] - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth)[this.thumbDrag] : 0)) / this.ifVerticalElse(elementBounds.bottom - elementBounds.top, elementBounds.right - elementBounds.left) * this.maxRangeWidth + this.options.min;\n\n    if (currPos < this.options.min) {\n      return this.options.min;\n    }\n\n    if (currPos > this.options.max) {\n      return this.options.max;\n    }\n\n    return currPos;\n  }\n\n  doesntHaveClassName(e, className) {\n    return !e.target.classList.contains(className);\n  }\n\n  elementFocused(e) {\n    let repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let setFocus = false;\n\n    if (!this.options.disabled && (this.doesntHaveClassName(e, 'range-slider__thumb') && this.doesntHaveClassName(e, 'range-slider__range') || this.options.rangeSlideDisabled && this.doesntHaveClassName(e, 'range-slider__thumb'))) {\n      setFocus = true;\n    } // No action if both thumbs are disabled\n\n\n    if (setFocus && this.options.thumbsDisabled[0] && this.options.thumbsDisabled[1]) {\n      setFocus = false;\n    }\n\n    if (setFocus) {\n      const currPos = this.currentPosition(e, this.range.current);\n      const deltaMin = abs(this.value.min - currPos);\n      const deltaMax = abs(this.value.max - currPos);\n\n      if (this.options.thumbsDisabled[0]) {\n        if (currPos >= this.value.min) {\n          this.setValue(this.setMinMaxProps(this.value.min, currPos), true, !repeat);\n          this.initiateThumbDrag(e, this.index.max, this.thumb[this.index.max].current, !repeat);\n        }\n      } else if (this.options.thumbsDisabled[1]) {\n        if (currPos <= this.value.max) {\n          this.setValue(this.setMinMaxProps(currPos, this.value.max), true, !repeat);\n          this.initiateThumbDrag(e, this.index.min, this.thumb[this.index.min].current, !repeat);\n        }\n      } else {\n        let nearestThumbIndex = this.index.max;\n\n        if (deltaMin === deltaMax) {\n          this.setValue(this.setMinMaxProps(this.value.min, currPos), true, !repeat);\n        } else {\n          this.setValue(this.setMinMaxProps(deltaMin < deltaMax ? currPos : this.value.min, deltaMax < deltaMin ? currPos : this.value.max), true, !repeat);\n          nearestThumbIndex = deltaMin < deltaMax ? this.index.min : this.index.max;\n        }\n\n        this.initiateThumbDrag(e, nearestThumbIndex, this.thumb[nearestThumbIndex].current, !repeat);\n      }\n\n      if (repeat) {\n        this.elementFocused(e, false);\n      }\n    }\n  }\n\n  initiateDrag(e, node) {\n    this.syncThumbDimensions();\n    this.setNodeAttribute(node, DATA_ACTIVE);\n    this.startPos = this.currentPosition(e, node);\n    this.isDragging = true;\n  }\n\n  initiateThumbDrag(e, i, node) {\n    let callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!this.options.disabled && !this.options.thumbsDisabled[this.currentIndex(i)]) {\n      this.initiateDrag(e, node);\n      this.thumbDrag = this.index.min === i ? MIN : MAX;\n\n      if (callback && this.options.onThumbDragStart) {\n        this.options.onThumbDragStart();\n      }\n    }\n  }\n\n  initiateRangeDrag(e) {\n    if (!this.options.disabled && !this.options.rangeSlideDisabled) {\n      this.initiateDrag(e, this.range.current);\n      this.rangeWidth = this.value.max - this.value.min;\n      this.thumbDrag = false;\n\n      if (this.options.onRangeDragStart) {\n        this.options.onRangeDragStart();\n      }\n    }\n  }\n\n  drag(e) {\n    if (this.isDragging) {\n      const lastPos = this.currentPosition(e, this.range.current);\n      const delta = lastPos - this.startPos;\n      let min = this.value.min;\n      let max = this.value.max;\n      const lower = this.thumbDrag ? this.rangeLimits.min : this.options.min;\n      const upper = this.thumbDrag ? this.rangeLimits.max : this.options.max;\n\n      if (!this.thumbDrag || this.thumbDrag === MIN) {\n        min = this.thumbDrag ? lastPos : this.sliderValue.min + delta;\n      }\n\n      if (!this.thumbDrag || this.thumbDrag === MAX) {\n        max = this.thumbDrag ? lastPos : this.sliderValue.max + delta;\n      }\n\n      if (min >= lower && min <= upper && max >= lower && max <= upper) {\n        this.setValue({\n          min,\n          max\n        });\n        this.startPos = lastPos;\n      } else {\n        // When min thumb reaches upper limit\n        if (min > upper && this.thumbDrag) {\n          this.setValue(this.setMinMaxProps(upper, upper));\n          this.startPos = lastPos;\n        } // When max thumb reaches lower limit\n\n\n        if (max < lower && this.thumbDrag) {\n          this.setValue(this.setMinMaxProps(lower, lower));\n          this.startPos = lastPos;\n        } // When range / min thumb reaches lower limit\n\n\n        if (min < lower) {\n          if (!this.thumbDrag) {\n            this.setValue(this.setMinMaxProps(lower, this.value.max - this.value.min + lower));\n          } else {\n            this.setValue(this.setMinMaxProps(lower, this.value.max));\n          }\n\n          this.startPos = lastPos;\n        } // When range / max thumb reaches upper limit\n\n\n        if (max > upper) {\n          if (!this.thumbDrag) {\n            this.setValue(this.setMinMaxProps(this.value.min - this.value.max + upper, upper));\n          } else {\n            this.setValue(this.setMinMaxProps(this.value.min, upper));\n          }\n\n          this.startPos = lastPos;\n        }\n      }\n\n      if (!this.thumbDrag) {\n        this.updateRangeLimits();\n      }\n    }\n  }\n\n  actualStepValue() {\n    const step = float(this.input[0].current.step);\n    return this.input[0].current.step === ANY ? ANY : step === 0 || isNaN(step) ? 1 : step;\n  } // Step value (up or down) using arrow keys\n\n\n  stepValue(i, key) {\n    const direction = (key === 37 || key === 40 ? -1 : 1) * this.ifVerticalElse(-1, 1);\n\n    if (!this.options.disabled && !this.options.thumbsDisabled[this.currentIndex(i)]) {\n      let step = this.actualStepValue();\n      step = step === ANY ? 1 : step;\n      let min = this.value.min + step * (this.index.min === i ? direction : 0);\n      let max = this.value.max + step * (this.index.max === i ? direction : 0); // When min thumb reaches upper limit\n\n      if (min > this.rangeLimits.max) {\n        min = this.rangeLimits.max;\n      } // When max thumb reaches lower limit\n\n\n      if (max < this.rangeLimits.min) {\n        max = this.rangeLimits.min;\n      }\n\n      this.setValue({\n        min,\n        max\n      }, true);\n    }\n  }\n\n  render() {\n    // Set options to default values if not set\n    this.fallbackToDefault('rangeSlideDisabled', false);\n    this.fallbackToDefault('thumbsDisabled', [false, false]);\n    this.fallbackToDefault('orientation', 'horizontal');\n    this.fallbackToDefault('defaultValue', [25, 75]);\n    this.fallbackToDefault('disabled', false);\n    this.fallbackToDefault('onThumbDragStart', false);\n    this.fallbackToDefault('onRangeDragStart', false);\n    this.fallbackToDefault('onThumbDragEnd', false);\n    this.fallbackToDefault('onRangeDragEnd', false);\n    this.fallbackToDefault('onInput', false);\n    this.fallbackToDefault('step', 1);\n    this.fallbackToDefault('min', 0);\n    this.fallbackToDefault('max', 100);\n\n    if (this.props.value) {\n      this.fallbackToDefault('value', [25, 75]);\n    }\n\n    this.safeMinMaxValues();\n    this.safeThumbsDisabledValues();\n    return /*#__PURE__*/_react.default.createElement(\"div\", {\n      \"data-testid\": \"element\",\n      id: this.props.id,\n      ref: this.element,\n      className: (0, _clsx.default)('range-slider', this.props.className)\n    }, /*#__PURE__*/_react.default.createElement(\"input\", {\n      ref: this.input[0],\n      type: \"range\",\n      min: this.options.min,\n      max: this.options.max,\n      step: this.options.step,\n      value: this.props.value ? this.options.value[0] : this.isComponentMounted ? this.value.min : this.options.defaultValue[0],\n      onChange: () => {},\n      disabled: true\n    }), /*#__PURE__*/_react.default.createElement(\"input\", {\n      ref: this.input[1],\n      type: \"range\",\n      min: this.options.min,\n      max: this.options.max,\n      step: this.options.step,\n      value: this.props.value ? this.options.value[1] : this.isComponentMounted ? this.value.max : this.options.defaultValue[1],\n      onChange: () => {},\n      disabled: true\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      ref: this.thumb[0],\n      role: \"slider\",\n      className: \"range-slider__thumb\",\n      \"data-lower\": true\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      ref: this.thumb[1],\n      role: \"slider\",\n      className: \"range-slider__thumb\",\n      \"data-upper\": true\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      ref: this.range,\n      className: \"range-slider__range\"\n    }));\n  }\n\n}\n\n;\nvar _default = RangeSlider;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0L2Rpc3QvY29tcG9uZW50cy9SYW5nZVNsaWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBTyxDQUFDLDZIQUFpRDs7QUFFekQsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsbUJBQU8sQ0FBQyxpR0FBbUM7O0FBRTNDLHFDQUFxQyxtQkFBTyxDQUFDLHdHQUFPOztBQUVwRCxtQ0FBbUMsbUJBQU8sQ0FBQyxzREFBTTs7QUFFakQsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsaURBQWlELGdEQUFnRCx1Q0FBdUMsc0NBQXNDLG9GQUFvRiw0REFBNEQ7O0FBRTlULHFEQUFxRCw2Q0FBNkMsY0FBYyw0RUFBNEUsU0FBUyxrQkFBa0IsbURBQW1ELCtCQUErQix5QkFBeUIsaUJBQWlCLHNGQUFzRix1QkFBdUIsMkVBQTJFLHFGQUFxRixzQ0FBc0MsNENBQTRDLE9BQU8sOEJBQThCLHNCQUFzQixhQUFhLDBCQUEwQjs7QUFFcHhCO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQSw4Q0FBOEM7O0FBRTlDO0FBQ0EsZ0RBQWdEOztBQUVoRCxnREFBZ0Q7O0FBRWhELGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHOztBQUV4RztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZXJjZS1wcm8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0L2Rpc3QvY29tcG9uZW50cy9SYW5nZVNsaWRlci5qcz9kZmRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtZmxvYXQuanNcIik7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLy8gQWxpYXNlc1xuY29uc3QgYWJzID0gTWF0aC5hYnM7XG5jb25zdCBmbG9hdCA9IHBhcnNlRmxvYXQ7IC8vIFZhbHVlc1xuXG5jb25zdCBNSU4gPSAnbWluJztcbmNvbnN0IE1BWCA9ICdtYXgnO1xuY29uc3QgQU5ZID0gJ2FueSc7XG5jb25zdCBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG5jb25zdCBUQUJJTkRFWCA9ICd0YWJpbmRleCc7IC8vIERhdGEgQXR0cmlidXRlc1xuXG5jb25zdCBEQVRBX0xPV0VSID0gJ2RhdGEtbG93ZXInO1xuY29uc3QgREFUQV9VUFBFUiA9ICdkYXRhLXVwcGVyJztcbmNvbnN0IERBVEFfQUNUSVZFID0gJ2RhdGEtYWN0aXZlJztcbmNvbnN0IERBVEFfVkVSVElDQUwgPSAnZGF0YS12ZXJ0aWNhbCc7XG5jb25zdCBEQVRBX0RJU0FCTEVEID0gJ2RhdGEtZGlzYWJsZWQnO1xuXG5jbGFzcyBSYW5nZVNsaWRlciBleHRlbmRzIF9yZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVsZW1lbnQgPSAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVSZWYpKCk7XG4gICAgdGhpcy5pbnB1dCA9IFsvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVSZWYpKCksIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZVJlZikoKV07XG4gICAgdGhpcy50aHVtYiA9IFsvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVSZWYpKCksIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZVJlZikoKV07XG4gICAgdGhpcy5yYW5nZSA9IC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZVJlZikoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmZpcnN0Q2FsbCA9IHRydWU7XG4gICAgdGhpcy5pc0NvbnRyb2xsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV4dGVybmFsSW5wdXQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFZhbHVlUHJvcCA9IFtdO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50TW91bnRlZCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc2V0TWluTWF4UHJvcHMoKTsgLy8gVGh1bWIgaW5kZXhlcyBmb3IgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgICAvLyAoc3dhcHBlZCB3aGVuIHRoZSB0aHVtYnMgY3Jvc3MgZWFjaCBvdGhlcilcblxuICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc2V0TWluTWF4UHJvcHMoMCwgMSk7IC8vIFRodW1iIHdpZHRoICYgaGVpZ2h0IGZvciBjYWxjdWxhdGlvbiBvZiBleGFjdCBwb3NpdGlvbnMgYW5kIHNpemVzIG9mIGhvcml6b250YWwgdGh1bWJzIGFuZCByYW5nZVxuXG4gICAgICB0aGlzLnRodW1iV2lkdGggPSB0aGlzLnNldE1pbk1heFByb3BzKCk7XG4gICAgICB0aGlzLnRodW1iSGVpZ2h0ID0gdGhpcy5zZXRNaW5NYXhQcm9wcygpOyAvLyBTbGlkYWJsZSByYW5nZSBsaW1pdHMgKHdoZW4gYSB0aHVtYiBpcyBkcmFnZ2VkKVxuXG4gICAgICB0aGlzLnJhbmdlTGltaXRzID0gdGhpcy5zZXRNaW5NYXhQcm9wcygpOyAvLyBTbGlkZXIgdmFsdWUgZGVwZW5kaW5nIG9uIHRoZSB1c2VyIGludGVyYWN0aW9uXG5cbiAgICAgIHRoaXMuc2xpZGVyVmFsdWUgPSB0aGlzLnNldE1pbk1heFByb3BzKCk7IC8vIEZvciBkcmFnZ2luZyB0aHVtYnMgYW5kIHJhbmdlXG5cbiAgICAgIHRoaXMubWF4UmFuZ2VXaWR0aCA9IDA7XG4gICAgICB0aGlzLnJhbmdlV2lkdGggPSAwO1xuICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRodW1iRHJhZyA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydFBvcyA9IDA7IC8vIGluaXRpYWxcblxuICAgICAgdGhpcy5yZXNldCgpOyAvLyBBZGQgbGlzdGVuZXJzIHRvIGVsZW1lbnRcblxuICAgICAgdGhpcy5hZGROb2RlRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQuY3VycmVudCwgJ3BvaW50ZXJkb3duJywgZSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudEZvY3VzZWQoZSk7XG4gICAgICB9KTsgLy8gQWRkIGxpc3RlbmVycyB0byB0aHVtYnMgYW5kIHNldCBbZGF0YS1kaXNhYmxlZF0gb24gZGlzYWJsZWQgdGh1bWJzXG5cbiAgICAgIHRoaXMudGh1bWIuZm9yRWFjaCgodCwgaSkgPT4ge1xuICAgICAgICB0aGlzLmFkZE5vZGVFdmVudExpc3RlbmVyKHQuY3VycmVudCwgJ3BvaW50ZXJkb3duJywgZSA9PiB7XG4gICAgICAgICAgdGhpcy5pbml0aWF0ZVRodW1iRHJhZyhlLCBpLCB0LmN1cnJlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGROb2RlRXZlbnRMaXN0ZW5lcih0LmN1cnJlbnQsICdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgICAgaWYgKGUud2hpY2ggPj0gMzcgJiYgZS53aGljaCA8PSA0MCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5zdGVwVmFsdWUoaSwgZS53aGljaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBBZGQgbGlzdGVuZXJzIHRvIHJhbmdlXG5cbiAgICAgIHRoaXMuYWRkTm9kZUV2ZW50TGlzdGVuZXIodGhpcy5yYW5nZS5jdXJyZW50LCAncG9pbnRlcmRvd24nLCBlID0+IHtcbiAgICAgICAgdGhpcy5pbml0aWF0ZVJhbmdlRHJhZyhlKTtcbiAgICAgIH0pOyAvLyBEZWZpbmUgYW5kIGFkZCBnbG9iYWwgbGlzdGVuZXJzXG5cbiAgICAgIHRoaXMucG9pbnRlck1vdmVFdmVudCA9IGUgPT4ge1xuICAgICAgICB0aGlzLmRyYWcoZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnBvaW50ZXJVcEV2ZW50ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVOb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbMF0uY3VycmVudCwgREFUQV9BQ1RJVkUpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iWzFdLmN1cnJlbnQsIERBVEFfQUNUSVZFKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVBdHRyaWJ1dGUodGhpcy5yYW5nZS5jdXJyZW50LCBEQVRBX0FDVElWRSk7XG4gICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodGhpcy50aHVtYkRyYWcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25UaHVtYkRyYWdFbmQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVGh1bWJEcmFnRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25SYW5nZURyYWdFbmQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uUmFuZ2VEcmFnRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJlc2l6ZUV2ZW50ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnN5bmNUaHVtYkRpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVUaHVtYnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZSgpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGROb2RlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5wb2ludGVyTW92ZUV2ZW50KTtcbiAgICAgIHRoaXMuYWRkTm9kZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLnBvaW50ZXJVcEV2ZW50KTtcbiAgICAgIHRoaXMuYWRkTm9kZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5yZXNpemVFdmVudCk7XG4gICAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIC8vIFJlbW92ZSBnbG9iYWwgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW1vdmVOb2RlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5wb2ludGVyTW92ZUV2ZW50KTtcbiAgICB0aGlzLnJlbW92ZU5vZGVFdmVudExpc3RlbmVyKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5wb2ludGVyVXBFdmVudCk7XG4gICAgdGhpcy5yZW1vdmVOb2RlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLnJlc2l6ZUV2ZW50KTtcbiAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pc0NvbnRyb2xsZWQgPSAhIXRoaXMucHJvcHMudmFsdWU7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRyb2xsZWQpIHtcbiAgICAgIGlmICh0aGlzLmZpcnN0Q2FsbCB8fCB0aGlzLnByb3BzLnZhbHVlICE9PSB0aGlzLmxhc3RWYWx1ZVByb3ApIHtcbiAgICAgICAgdGhpcy5maXJzdENhbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHRlcm5hbElucHV0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0VmFsdWVQcm9wID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLm1heFJhbmdlV2lkdGggPSB0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5vcHRpb25zLm1pbjtcbiAgICB0aGlzLnVwZGF0ZU9yaWVudGF0aW9uKCk7XG4gICAgdGhpcy5zZXRWYWx1ZSgnJywgdHJ1ZSwgZmFsc2UpO1xuICAgIHRoaXMudXBkYXRlUmFuZ2VMaW1pdHMoKTtcbiAgICB0aGlzLnVwZGF0ZURpc2FibGVkU3RhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZVRodW1ic0Rpc2FibGVkU3RhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZVRhYkluZGV4ZXMoKTtcbiAgfVxuXG4gIGlzTnVtYmVyKG4pIHtcbiAgICAvLyBjaGVjayBmb3IgTmFOIGV4cGxpY2l0bHlcbiAgICAvLyBiZWNhdXNlIHdpdGggTmFOLCB0aGUgc2Vjb25kIGV4cC4gZXZhbHVhdGVzIHRvIHRydWVcbiAgICByZXR1cm4gIWlzTmFOKG4pICYmICtuICsgJycgPT09IG4gKyAnJztcbiAgfVxuXG4gIHNldE1pbk1heFByb3BzKCkge1xuICAgIGxldCBtaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgbGV0IG1heCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfTtcbiAgfVxuXG4gIGl0ZXJhdGVNaW5NYXhQcm9wcyhmbikge1xuICAgIFtNSU4sIE1BWF0uZm9yRWFjaChmbik7XG4gIH1cblxuICBnZXRTZXRQcm9wcyhjb25kaXRpb24sIGV4cHJlc3Npb24sIGZuKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGUpIHtcbiAgICBsZXQgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICB9XG5cbiAgcmVtb3ZlTm9kZUF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGUpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9XG5cbiAgYWRkTm9kZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGZuKSB7XG4gICAgbGV0IGlzUG9pbnRlckV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgIC8vIHdpdGggb3B0aW9ucyBmb3IgcG9pbnRlciBldmVudHNcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBpc1BvaW50ZXJFdmVudCA/IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0gOiB7fSk7XG4gIH1cblxuICByZW1vdmVOb2RlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgZm4pIHtcbiAgICBsZXQgaXNQb2ludGVyRXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgLy8gd2l0aCBvcHRpb25zIGZvciBwb2ludGVyIGV2ZW50c1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIGlzUG9pbnRlckV2ZW50ID8ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSA6IHt9KTtcbiAgfVxuXG4gIGZhbGxiYWNrVG9EZWZhdWx0KHByb3BlcnR5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLm9wdGlvbnNbcHJvcGVydHldID0gdGhpcy5wcm9wc1twcm9wZXJ0eV0gPyB0aGlzLnByb3BzW3Byb3BlcnR5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIGlmVmVydGljYWxFbHNlKHZlcnRpY2FsLCBob3Jpem9udGFsKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gVkVSVElDQUwgPyB2ZXJ0aWNhbCA6IGhvcml6b250YWw7XG4gIH1cblxuICBjdXJyZW50SW5kZXgoaSkge1xuICAgIHJldHVybiBpID09PSAxID8gdGhpcy5pbmRleC5tYXggOiB0aGlzLmluZGV4Lm1pbjtcbiAgfSAvLyBTZXQgbWluIGFuZCBtYXggdmFsdWVzIHRvIDEgKGFyYml0cmFyaWx5KSBpZiBhbnkgb2YgdGhlIG1pbiBvciBtYXggdmFsdWVzIGFyZSBcImludmFsaWRcIlxuICAvLyBTZXR0aW5nIGJvdGggdmFsdWVzIDEgd2lsbCBkaXNhYmxlIHRoZSBzbGlkZXJcbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRoZSBlbGVtZW50IGlzIGluaXRpYWxseSBzZXRcbiAgLy8gLT4gbWluIG9yIG1heCBwcm9wZXJ0aWVzIGFyZSBtb2RpZmllZFxuXG5cbiAgc2FmZU1pbk1heFZhbHVlcygpIHtcbiAgICBsZXQgZXJyb3IgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5pc051bWJlcih0aGlzLm9wdGlvbnMubWluKSB8fCAhdGhpcy5pc051bWJlcih0aGlzLm9wdGlvbnMubWF4KSkge1xuICAgICAgZXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5taW4gPSBlcnJvciA/IDEgOiArdGhpcy5vcHRpb25zLm1pbjtcbiAgICB0aGlzLm9wdGlvbnMubWF4ID0gZXJyb3IgPyAxIDogK3RoaXMub3B0aW9ucy5tYXg7XG4gIH0gLy8gUmVmcmFtZSB0aGUgdGh1bWJzRGlzYWJsZWQgdmFsdWUgaWYgXCJpbnZhbGlkXCJcbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRoZSBlbGVtZW50IGlzIGluaXRpYWxseSBzZXRcbiAgLy8gLT4gdGh1bWJzRGlzYWJsZWQgcHJvcGVydHkgaXMgbW9kaWZpZWRcblxuXG4gIHNhZmVUaHVtYnNEaXNhYmxlZFZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZC5wdXNoKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZC5sZW5ndGggIT09IDEgJiYgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWQgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkID0gW3RoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZCwgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkXTtcbiAgICB9IC8vIEJvb2xlYW4gVmFsdWVzXG5cblxuICAgIHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFswXSA9ICEhdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkWzBdO1xuICAgIHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFsxXSA9ICEhdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkWzFdO1xuICB9IC8vIENhbGxlZCB3aGVuLFxuICAvLyAtPiB0aGUgZWxlbWVudCBpcyBpbml0aWFsbHkgc2V0XG4gIC8vIC0+IG1pbiwgbWF4LCBzdGVwIG9yIHZhbHVlIHByb3BlcnRpZXMgYXJlIG1vZGlmaWVkXG4gIC8vIC0+IHRodW1icyBhcmUgZHJhZ2dlZFxuICAvLyAtPiBlbGVtZW50IGlzIGNsaWNrZWQgdXBvblxuICAvLyAtPiBhbiBhcnJvdyBrZXkgaXMgcHJlc3NlZFxuXG5cbiAgc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICBsZXQgZm9yY2VTZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAvLyBDdXJyZW50IHZhbHVlIGFzIHNldCBpbiB0aGUgaW5wdXQgZWxlbWVudHNcbiAgICAvLyB3aGljaCBjb3VsZCBjaGFuZ2Ugd2hpbGUgY2hhbmdpbmcgbWluLCBtYXggYW5kIHN0ZXAgdmFsdWVzXG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5zZXRNaW5NYXhQcm9wcyh0aGlzLmlucHV0WzBdLmN1cnJlbnQudmFsdWUsIHRoaXMuaW5wdXRbMV0uY3VycmVudC52YWx1ZSk7IC8vIHZhciB2YWx1ZSBpcyBzeW5jZWQgd2l0aCB0aGUgdmFsdWVzIHNldCBpbiB0aGUgaW5wdXQgZWxlbWVudHMgaWYgbm8gbmV3VmFsdWUgaXMgcGFzc2VkXG5cbiAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlIHx8IGN1cnJlbnRWYWx1ZTtcbiAgICB0aGlzLmlucHV0W3RoaXMuaW5kZXgubWluXS5jdXJyZW50LnZhbHVlID0gbmV3VmFsdWUubWluO1xuICAgIHRoaXMuaW5wdXRbdGhpcy5pbmRleC5tYXhdLmN1cnJlbnQudmFsdWUgPSB0aGlzLnRodW1iRHJhZyB8fCBmb3JjZVNldCA/IG5ld1ZhbHVlLm1heCA6IG5ld1ZhbHVlLm1pbiArIHRoaXMucmFuZ2VXaWR0aDtcbiAgICB0aGlzLnN5bmNWYWx1ZXMoKTsgLy8gQ2hlY2sgaWYgdGhlIHRodW1icyBjcm9zcyBlYWNoIG90aGVyXG5cbiAgICBpZiAodGhpcy52YWx1ZS5taW4gPiB0aGlzLnZhbHVlLm1heCkge1xuICAgICAgLy8gU3dpdGNoIHRodW1iIGluZGV4ZXNcbiAgICAgIHRoaXMuaW5kZXgubWluID0gKyF0aGlzLmluZGV4Lm1pbjtcbiAgICAgIHRoaXMuaW5kZXgubWF4ID0gKyF0aGlzLmluZGV4Lm1heDsgLy8gU3dpdGNoIHRodW1iIGF0dHJpYnV0ZXNcblxuICAgICAgdGhpcy5yZW1vdmVOb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbdGhpcy5pbmRleC5taW5dLmN1cnJlbnQsIERBVEFfVVBQRVIpO1xuICAgICAgdGhpcy5yZW1vdmVOb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbdGhpcy5pbmRleC5tYXhdLmN1cnJlbnQsIERBVEFfTE9XRVIpO1xuICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbdGhpcy5pbmRleC5taW5dLmN1cnJlbnQsIERBVEFfTE9XRVIpO1xuICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbdGhpcy5pbmRleC5tYXhdLmN1cnJlbnQsIERBVEFfVVBQRVIpOyAvLyBTd2l0Y2ggdGh1bWIgZHJhZyBsYWJlbHNcblxuICAgICAgaWYgKHRoaXMudGh1bWJEcmFnKSB7XG4gICAgICAgIHRoaXMudGh1bWJEcmFnID0gdGhpcy50aHVtYkRyYWcgPT09IE1JTiA/IE1BWCA6IE1JTjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zeW5jVmFsdWVzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zbGlkZXJWYWx1ZSA9IGZvcmNlU2V0ID8gdGhpcy52YWx1ZSA6IG5ld1ZhbHVlO1xuICAgIGxldCB2YWx1ZVNldCA9IGZhbHNlO1xuXG4gICAgaWYgKGN1cnJlbnRWYWx1ZS5taW4gIT09IHRoaXMuaW5wdXRbMF0uY3VycmVudC52YWx1ZSB8fCBmb3JjZVNldCkge1xuICAgICAgdmFsdWVTZXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VmFsdWUubWF4ICE9PSB0aGlzLmlucHV0WzFdLmN1cnJlbnQudmFsdWUgfHwgZm9yY2VTZXQpIHtcbiAgICAgIHZhbHVlU2V0ID0gdHJ1ZTtcbiAgICB9IC8vIFVwZGF0ZSB0aGUgcG9zaXRpb25zLCBkaW1lbnNpb25zIGFuZCBhcmlhIGF0dHJpYnV0ZXMgZXZlcnl0aW1lIGEgdmFsdWUgaXMgc2V0XG4gICAgLy8gYW5kIGNhbGwgdGhlIG9uSW5wdXQgZnVuY3Rpb24gZnJvbSBvcHRpb25zIChpZiBzZXQpXG5cblxuICAgIGlmICh2YWx1ZVNldCkge1xuICAgICAgaWYgKGNhbGxiYWNrICYmIHRoaXMub3B0aW9ucy5vbklucHV0KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbklucHV0KFt0aGlzLnZhbHVlLm1pbiwgdGhpcy52YWx1ZS5tYXhdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzQ29udHJvbGxlZCB8fCB0aGlzLmV4dGVybmFsSW5wdXQpIHtcbiAgICAgICAgdGhpcy5leHRlcm5hbElucHV0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luY1RodW1iRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRodW1icygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXJpYVZhbHVlQXR0cmlidXRlcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTeW5jIHZhciB2YWx1ZSB3aXRoIHRoZSBpbnB1dCBlbGVtZW50c1xuXG5cbiAgc3luY1ZhbHVlcygpIHtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcyhfID0+IHtcbiAgICAgIHRoaXMudmFsdWVbX10gPSArdGhpcy5pbnB1dFt0aGlzLmluZGV4W19dXS5jdXJyZW50LnZhbHVlO1xuICAgIH0pO1xuICB9IC8vIENhbGxlZCB3aGVuLFxuICAvLyAtPiBzZXRWYWx1ZSBpcyBjYWxsZWQgYW5kIGEgdmFsdWUgaXMgc2V0XG4gIC8vIC0+IHdpbmRvdyBpcyByZXNpemVkXG5cblxuICB1cGRhdGVUaHVtYnMoKSB7XG4gICAgdGhpcy5pdGVyYXRlTWluTWF4UHJvcHMoXyA9PiB7XG4gICAgICB0aGlzLnRodW1iW3RoaXMuaW5kZXhbX11dLmN1cnJlbnQuc3R5bGVbdGhpcy5pZlZlcnRpY2FsRWxzZSgndG9wJywgJ2xlZnQnKV0gPSBcImNhbGMoXCIuY29uY2F0KCh0aGlzLnZhbHVlW19dIC0gdGhpcy5vcHRpb25zLm1pbikgLyB0aGlzLm1heFJhbmdlV2lkdGggKiAxMDAsIFwiJSArIFwiKS5jb25jYXQoKDAuNSAtICh0aGlzLnZhbHVlW19dIC0gdGhpcy5vcHRpb25zLm1pbikgLyB0aGlzLm1heFJhbmdlV2lkdGgpICogdGhpcy5pZlZlcnRpY2FsRWxzZSh0aGlzLnRodW1iSGVpZ2h0LCB0aGlzLnRodW1iV2lkdGgpW19dLCBcInB4KVwiKTtcbiAgICB9KTtcbiAgfSAvLyBDYWxsZWQgd2hlbixcbiAgLy8gLT4gc2V0VmFsdWUgaXMgY2FsbGVkIGFuZCBhIHZhbHVlIGlzIHNldFxuICAvLyAtPiB3aW5kb3cgaXMgcmVzaXplZFxuXG5cbiAgdXBkYXRlUmFuZ2UoKSB7XG4gICAgY29uc3QgZWxlbWVudEJvdW5kcyA9IHRoaXMuZWxlbWVudC5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gKDAuNSAtICh0aGlzLnZhbHVlLm1pbiAtIHRoaXMub3B0aW9ucy5taW4pIC8gdGhpcy5tYXhSYW5nZVdpZHRoKSAqIHRoaXMuaWZWZXJ0aWNhbEVsc2UodGhpcy50aHVtYkhlaWdodCwgdGhpcy50aHVtYldpZHRoKS5taW4gLyB0aGlzLmlmVmVydGljYWxFbHNlKGVsZW1lbnRCb3VuZHMuYm90dG9tIC0gZWxlbWVudEJvdW5kcy50b3AsIGVsZW1lbnRCb3VuZHMucmlnaHQgLSBlbGVtZW50Qm91bmRzLmxlZnQpO1xuICAgIGNvbnN0IGRlbHRhRGltZW5zaW9uID0gKDAuNSAtICh0aGlzLnZhbHVlLm1heCAtIHRoaXMub3B0aW9ucy5taW4pIC8gdGhpcy5tYXhSYW5nZVdpZHRoKSAqIHRoaXMuaWZWZXJ0aWNhbEVsc2UodGhpcy50aHVtYkhlaWdodCwgdGhpcy50aHVtYldpZHRoKS5tYXggLyB0aGlzLmlmVmVydGljYWxFbHNlKGVsZW1lbnRCb3VuZHMuYm90dG9tIC0gZWxlbWVudEJvdW5kcy50b3AsIGVsZW1lbnRCb3VuZHMucmlnaHQgLSBlbGVtZW50Qm91bmRzLmxlZnQpO1xuICAgIHRoaXMucmFuZ2UuY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCd0b3AnLCAnbGVmdCcpXSA9IFwiXCIuY29uY2F0KCgodGhpcy52YWx1ZS5taW4gLSB0aGlzLm9wdGlvbnMubWluKSAvIHRoaXMubWF4UmFuZ2VXaWR0aCArIGRlbHRhT2Zmc2V0KSAqIDEwMCwgXCIlXCIpO1xuICAgIHRoaXMucmFuZ2UuY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCdoZWlnaHQnLCAnd2lkdGgnKV0gPSBcIlwiLmNvbmNhdCgoKHRoaXMudmFsdWUubWF4IC0gdGhpcy5vcHRpb25zLm1pbikgLyB0aGlzLm1heFJhbmdlV2lkdGggLSAodGhpcy52YWx1ZS5taW4gLSB0aGlzLm9wdGlvbnMubWluKSAvIHRoaXMubWF4UmFuZ2VXaWR0aCAtIGRlbHRhT2Zmc2V0ICsgZGVsdGFEaW1lbnNpb24pICogMTAwLCBcIiVcIik7XG4gIH1cblxuICB1cGRhdGVSYW5nZUxpbWl0cygpIHtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcygoXywgaSkgPT4ge1xuICAgICAgdGhpcy5yYW5nZUxpbWl0c1tfXSA9IHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFtpXSA/IHRoaXMudmFsdWVbX10gOiB0aGlzLm9wdGlvbnNbX107XG4gICAgfSk7XG4gIH0gLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRodW1icyBhcmUgaW5pdGlhbGx5IHNldFxuICAvLyAtPiB0aHVtYnMgYXJlIGRpc2FibGVkIC8gZW5hYmxlZFxuXG5cbiAgdXBkYXRlVGFiSW5kZXhlcygpIHtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcygoXywgaSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgIXRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFtpXSkge1xuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYlt0aGlzLmN1cnJlbnRJbmRleChpKV0uY3VycmVudCwgVEFCSU5ERVgsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbdGhpcy5jdXJyZW50SW5kZXgoaSldLmN1cnJlbnQsIFRBQklOREVYKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBDYWxsZWQgd2hlbixcbiAgLy8gLT4gc2V0VmFsdWUgaXMgY2FsbGVkIGFuZCBhIHZhbHVlIGlzIHNldFxuXG5cbiAgdXBkYXRlQXJpYVZhbHVlQXR0cmlidXRlcygpIHtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcyhfID0+IHtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXhbX11dLmN1cnJlbnQsICdhcmlhLXZhbHVlbWluJywgdGhpcy5vcHRpb25zLm1pbik7XG4gICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYlt0aGlzLmluZGV4W19dXS5jdXJyZW50LCAnYXJpYS12YWx1ZW1heCcsIHRoaXMub3B0aW9ucy5tYXgpO1xuICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbdGhpcy5pbmRleFtfXV0uY3VycmVudCwgJ2FyaWEtdmFsdWVub3cnLCB0aGlzLnZhbHVlW19dKTtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXhbX11dLmN1cnJlbnQsICdhcmlhLXZhbHVldGV4dCcsIHRoaXMudmFsdWVbX10pO1xuICAgIH0pO1xuICB9IC8vIENhbGxlZCB3aGVuLFxuICAvLyAtPiBkaXNhYmxlZCBwcm9wZXJ0eSBpcyBtb2RpZmllZFxuXG5cbiAgdXBkYXRlRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy5lbGVtZW50LmN1cnJlbnQsIERBVEFfRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGVBdHRyaWJ1dGUodGhpcy5lbGVtZW50LmN1cnJlbnQsIERBVEFfRElTQUJMRUQpO1xuICAgIH1cbiAgfSAvLyBDYWxsZWQgd2hlbixcbiAgLy8gLT4gdGh1bWJzRGlzYWJsZWQgcHJvcGVydHkgaXMgbW9kaWZpZWRcblxuXG4gIHVwZGF0ZVRodW1ic0Rpc2FibGVkU3RhdGUoKSB7XG4gICAgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJJbmRleCA9IHRoaXMuY3VycmVudEluZGV4KGkpO1xuXG4gICAgICBpZiAoZCkge1xuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsIERBVEFfRElTQUJMRUQpO1xuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsICdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZU5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsIERBVEFfRElTQUJMRUQpO1xuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsICdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIENhbGxlZCB3aGVuLFxuICAvLyAtPiBtaW4gb3IgbWF4IHZhbHVlcyBhcmUgbW9kaWZpZWRcblxuXG4gIHVwZGF0ZUxpbWl0cyhsaW1pdCkge1xuICAgIGxldCBtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnNbbGltaXRdID0gbTtcbiAgICB0aGlzLnNhZmVNaW5NYXhWYWx1ZXMoKTtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcyhfID0+IHtcbiAgICAgIHRoaXMuaW5wdXRbMF0uY3VycmVudFtfXSA9IHRoaXMub3B0aW9uc1tfXTtcbiAgICAgIHRoaXMuaW5wdXRbMV0uY3VycmVudFtfXSA9IHRoaXMub3B0aW9uc1tfXTtcbiAgICB9KTtcbiAgICB0aGlzLm1heFJhbmdlV2lkdGggPSB0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5vcHRpb25zLm1pbjtcbiAgICB0aGlzLnNldFZhbHVlKCcnLCB0cnVlKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlTGltaXRzKCk7XG4gIH0gLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRoZSBlbGVtZW50IGlzIGluaXRpYWxseSBzZXRcbiAgLy8gLT4gb3JpZW50YXRpb24gcHJvcGVydHkgaXMgbW9kaWZpZWRcblxuXG4gIHVwZGF0ZU9yaWVudGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09IFZFUlRJQ0FMKSB7XG4gICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy5lbGVtZW50LmN1cnJlbnQsIERBVEFfVkVSVElDQUwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGVBdHRyaWJ1dGUodGhpcy5lbGVtZW50LmN1cnJlbnQsIERBVEFfVkVSVElDQUwpO1xuICAgIH1cblxuICAgIHRoaXMucmFuZ2UuY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCdsZWZ0JywgJ3RvcCcpXSA9ICcnO1xuICAgIHRoaXMucmFuZ2UuY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCd3aWR0aCcsICdoZWlnaHQnKV0gPSAnJztcbiAgICB0aGlzLnRodW1iWzBdLmN1cnJlbnQuc3R5bGVbdGhpcy5pZlZlcnRpY2FsRWxzZSgnbGVmdCcsICd0b3AnKV0gPSAnJztcbiAgICB0aGlzLnRodW1iWzFdLmN1cnJlbnQuc3R5bGVbdGhpcy5pZlZlcnRpY2FsRWxzZSgnbGVmdCcsICd0b3AnKV0gPSAnJztcbiAgfSAvLyB0aHVtYiB3aWR0aCAmIGhlaWdodCB2YWx1ZXMgYXJlIHRvIGJlIHN5bmNlZCB3aXRoIHRoZSBDU1MgdmFsdWVzIGZvciBjb3JyZWN0IGNhbGN1bGF0aW9uIG9mXG4gIC8vIHRodW1iIHBvc2l0aW9uIGFuZCByYW5nZSB3aWR0aCAmIHBvc2l0aW9uXG4gIC8vIENhbGxlZCB3aGVuLFxuICAvLyAtPiBzZXRWYWx1ZSBpcyBjYWxsZWQgYW5kIGEgdmFsdWUgaXMgc2V0IChjYWxsZWQgYmVmb3JlIHVwZGF0ZVRodW1icygpIGFuZCB1cGRhdGVSYW5nZSgpKVxuICAvLyAtPiB0aHVtYiAvIHJhbmdlIGRyYWcgaXMgaW5pdGlhdGVkXG4gIC8vIC0+IHdpbmRvdyBpcyByZXNpemVkXG5cblxuICBzeW5jVGh1bWJEaW1lbnNpb25zKCkge1xuICAgIHRoaXMuaXRlcmF0ZU1pbk1heFByb3BzKF8gPT4ge1xuICAgICAgdGhpcy50aHVtYldpZHRoW19dID0gZmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy50aHVtYlt0aGlzLmluZGV4W19dXS5jdXJyZW50KS53aWR0aCk7XG4gICAgICB0aGlzLnRodW1iSGVpZ2h0W19dID0gZmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy50aHVtYlt0aGlzLmluZGV4W19dXS5jdXJyZW50KS5oZWlnaHQpO1xuICAgIH0pO1xuICB9IC8vIHRodW1iIHBvc2l0aW9uIGNhbGN1bGF0aW9uIGRlcGVuZGluZyB1cG9uIHRoZSBwb2ludGVyIHBvc2l0aW9uXG5cblxuICBjdXJyZW50UG9zaXRpb24oZSwgbm9kZSkge1xuICAgIGNvbnN0IGVsZW1lbnRCb3VuZHMgPSB0aGlzLmVsZW1lbnQuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBub2RlQm91bmRzID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjdXJyUG9zID0gKHRoaXMuaWZWZXJ0aWNhbEVsc2Uobm9kZUJvdW5kcy50b3AgLSBlbGVtZW50Qm91bmRzLnRvcCwgbm9kZUJvdW5kcy5sZWZ0IC0gZWxlbWVudEJvdW5kcy5sZWZ0KSArIChlW1wiY2xpZW50XCIuY29uY2F0KHRoaXMuaWZWZXJ0aWNhbEVsc2UoJ1knLCAnWCcpKV0gLSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMuaWZWZXJ0aWNhbEVsc2UoJ3RvcCcsICdsZWZ0JyldKSAtICh0aGlzLnRodW1iRHJhZyA/ICgwLjUgLSAodGhpcy52YWx1ZVt0aGlzLnRodW1iRHJhZ10gLSB0aGlzLm9wdGlvbnMubWluKSAvIHRoaXMubWF4UmFuZ2VXaWR0aCkgKiB0aGlzLmlmVmVydGljYWxFbHNlKHRoaXMudGh1bWJIZWlnaHQsIHRoaXMudGh1bWJXaWR0aClbdGhpcy50aHVtYkRyYWddIDogMCkpIC8gdGhpcy5pZlZlcnRpY2FsRWxzZShlbGVtZW50Qm91bmRzLmJvdHRvbSAtIGVsZW1lbnRCb3VuZHMudG9wLCBlbGVtZW50Qm91bmRzLnJpZ2h0IC0gZWxlbWVudEJvdW5kcy5sZWZ0KSAqIHRoaXMubWF4UmFuZ2VXaWR0aCArIHRoaXMub3B0aW9ucy5taW47XG5cbiAgICBpZiAoY3VyclBvcyA8IHRoaXMub3B0aW9ucy5taW4pIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWluO1xuICAgIH1cblxuICAgIGlmIChjdXJyUG9zID4gdGhpcy5vcHRpb25zLm1heCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJQb3M7XG4gIH1cblxuICBkb2VzbnRIYXZlQ2xhc3NOYW1lKGUsIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiAhZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gIH1cblxuICBlbGVtZW50Rm9jdXNlZChlKSB7XG4gICAgbGV0IHJlcGVhdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICBsZXQgc2V0Rm9jdXMgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmICh0aGlzLmRvZXNudEhhdmVDbGFzc05hbWUoZSwgJ3JhbmdlLXNsaWRlcl9fdGh1bWInKSAmJiB0aGlzLmRvZXNudEhhdmVDbGFzc05hbWUoZSwgJ3JhbmdlLXNsaWRlcl9fcmFuZ2UnKSB8fCB0aGlzLm9wdGlvbnMucmFuZ2VTbGlkZURpc2FibGVkICYmIHRoaXMuZG9lc250SGF2ZUNsYXNzTmFtZShlLCAncmFuZ2Utc2xpZGVyX190aHVtYicpKSkge1xuICAgICAgc2V0Rm9jdXMgPSB0cnVlO1xuICAgIH0gLy8gTm8gYWN0aW9uIGlmIGJvdGggdGh1bWJzIGFyZSBkaXNhYmxlZFxuXG5cbiAgICBpZiAoc2V0Rm9jdXMgJiYgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkWzBdICYmIHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFsxXSkge1xuICAgICAgc2V0Rm9jdXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2V0Rm9jdXMpIHtcbiAgICAgIGNvbnN0IGN1cnJQb3MgPSB0aGlzLmN1cnJlbnRQb3NpdGlvbihlLCB0aGlzLnJhbmdlLmN1cnJlbnQpO1xuICAgICAgY29uc3QgZGVsdGFNaW4gPSBhYnModGhpcy52YWx1ZS5taW4gLSBjdXJyUG9zKTtcbiAgICAgIGNvbnN0IGRlbHRhTWF4ID0gYWJzKHRoaXMudmFsdWUubWF4IC0gY3VyclBvcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbMF0pIHtcbiAgICAgICAgaWYgKGN1cnJQb3MgPj0gdGhpcy52YWx1ZS5taW4pIHtcbiAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuc2V0TWluTWF4UHJvcHModGhpcy52YWx1ZS5taW4sIGN1cnJQb3MpLCB0cnVlLCAhcmVwZWF0KTtcbiAgICAgICAgICB0aGlzLmluaXRpYXRlVGh1bWJEcmFnKGUsIHRoaXMuaW5kZXgubWF4LCB0aGlzLnRodW1iW3RoaXMuaW5kZXgubWF4XS5jdXJyZW50LCAhcmVwZWF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbMV0pIHtcbiAgICAgICAgaWYgKGN1cnJQb3MgPD0gdGhpcy52YWx1ZS5tYXgpIHtcbiAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuc2V0TWluTWF4UHJvcHMoY3VyclBvcywgdGhpcy52YWx1ZS5tYXgpLCB0cnVlLCAhcmVwZWF0KTtcbiAgICAgICAgICB0aGlzLmluaXRpYXRlVGh1bWJEcmFnKGUsIHRoaXMuaW5kZXgubWluLCB0aGlzLnRodW1iW3RoaXMuaW5kZXgubWluXS5jdXJyZW50LCAhcmVwZWF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG5lYXJlc3RUaHVtYkluZGV4ID0gdGhpcy5pbmRleC5tYXg7XG5cbiAgICAgICAgaWYgKGRlbHRhTWluID09PSBkZWx0YU1heCkge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyh0aGlzLnZhbHVlLm1pbiwgY3VyclBvcyksIHRydWUsICFyZXBlYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyhkZWx0YU1pbiA8IGRlbHRhTWF4ID8gY3VyclBvcyA6IHRoaXMudmFsdWUubWluLCBkZWx0YU1heCA8IGRlbHRhTWluID8gY3VyclBvcyA6IHRoaXMudmFsdWUubWF4KSwgdHJ1ZSwgIXJlcGVhdCk7XG4gICAgICAgICAgbmVhcmVzdFRodW1iSW5kZXggPSBkZWx0YU1pbiA8IGRlbHRhTWF4ID8gdGhpcy5pbmRleC5taW4gOiB0aGlzLmluZGV4Lm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhdGVUaHVtYkRyYWcoZSwgbmVhcmVzdFRodW1iSW5kZXgsIHRoaXMudGh1bWJbbmVhcmVzdFRodW1iSW5kZXhdLmN1cnJlbnQsICFyZXBlYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVwZWF0KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEZvY3VzZWQoZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluaXRpYXRlRHJhZyhlLCBub2RlKSB7XG4gICAgdGhpcy5zeW5jVGh1bWJEaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKG5vZGUsIERBVEFfQUNUSVZFKTtcbiAgICB0aGlzLnN0YXJ0UG9zID0gdGhpcy5jdXJyZW50UG9zaXRpb24oZSwgbm9kZSk7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGluaXRpYXRlVGh1bWJEcmFnKGUsIGksIG5vZGUpIHtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiAhdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkW3RoaXMuY3VycmVudEluZGV4KGkpXSkge1xuICAgICAgdGhpcy5pbml0aWF0ZURyYWcoZSwgbm9kZSk7XG4gICAgICB0aGlzLnRodW1iRHJhZyA9IHRoaXMuaW5kZXgubWluID09PSBpID8gTUlOIDogTUFYO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgdGhpcy5vcHRpb25zLm9uVGh1bWJEcmFnU3RhcnQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uVGh1bWJEcmFnU3RhcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbml0aWF0ZVJhbmdlRHJhZyhlKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgIXRoaXMub3B0aW9ucy5yYW5nZVNsaWRlRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhdGVEcmFnKGUsIHRoaXMucmFuZ2UuY3VycmVudCk7XG4gICAgICB0aGlzLnJhbmdlV2lkdGggPSB0aGlzLnZhbHVlLm1heCAtIHRoaXMudmFsdWUubWluO1xuICAgICAgdGhpcy50aHVtYkRyYWcgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblJhbmdlRHJhZ1N0YXJ0KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblJhbmdlRHJhZ1N0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhZyhlKSB7XG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgY29uc3QgbGFzdFBvcyA9IHRoaXMuY3VycmVudFBvc2l0aW9uKGUsIHRoaXMucmFuZ2UuY3VycmVudCk7XG4gICAgICBjb25zdCBkZWx0YSA9IGxhc3RQb3MgLSB0aGlzLnN0YXJ0UG9zO1xuICAgICAgbGV0IG1pbiA9IHRoaXMudmFsdWUubWluO1xuICAgICAgbGV0IG1heCA9IHRoaXMudmFsdWUubWF4O1xuICAgICAgY29uc3QgbG93ZXIgPSB0aGlzLnRodW1iRHJhZyA/IHRoaXMucmFuZ2VMaW1pdHMubWluIDogdGhpcy5vcHRpb25zLm1pbjtcbiAgICAgIGNvbnN0IHVwcGVyID0gdGhpcy50aHVtYkRyYWcgPyB0aGlzLnJhbmdlTGltaXRzLm1heCA6IHRoaXMub3B0aW9ucy5tYXg7XG5cbiAgICAgIGlmICghdGhpcy50aHVtYkRyYWcgfHwgdGhpcy50aHVtYkRyYWcgPT09IE1JTikge1xuICAgICAgICBtaW4gPSB0aGlzLnRodW1iRHJhZyA/IGxhc3RQb3MgOiB0aGlzLnNsaWRlclZhbHVlLm1pbiArIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMudGh1bWJEcmFnIHx8IHRoaXMudGh1bWJEcmFnID09PSBNQVgpIHtcbiAgICAgICAgbWF4ID0gdGhpcy50aHVtYkRyYWcgPyBsYXN0UG9zIDogdGhpcy5zbGlkZXJWYWx1ZS5tYXggKyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA+PSBsb3dlciAmJiBtaW4gPD0gdXBwZXIgJiYgbWF4ID49IGxvd2VyICYmIG1heCA8PSB1cHBlcikge1xuICAgICAgICB0aGlzLnNldFZhbHVlKHtcbiAgICAgICAgICBtaW4sXG4gICAgICAgICAgbWF4XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gbWluIHRodW1iIHJlYWNoZXMgdXBwZXIgbGltaXRcbiAgICAgICAgaWYgKG1pbiA+IHVwcGVyICYmIHRoaXMudGh1bWJEcmFnKSB7XG4gICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnNldE1pbk1heFByb3BzKHVwcGVyLCB1cHBlcikpO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3MgPSBsYXN0UG9zO1xuICAgICAgICB9IC8vIFdoZW4gbWF4IHRodW1iIHJlYWNoZXMgbG93ZXIgbGltaXRcblxuXG4gICAgICAgIGlmIChtYXggPCBsb3dlciAmJiB0aGlzLnRodW1iRHJhZykge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyhsb3dlciwgbG93ZXIpKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgICAgfSAvLyBXaGVuIHJhbmdlIC8gbWluIHRodW1iIHJlYWNoZXMgbG93ZXIgbGltaXRcblxuXG4gICAgICAgIGlmIChtaW4gPCBsb3dlcikge1xuICAgICAgICAgIGlmICghdGhpcy50aHVtYkRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyhsb3dlciwgdGhpcy52YWx1ZS5tYXggLSB0aGlzLnZhbHVlLm1pbiArIGxvd2VyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyhsb3dlciwgdGhpcy52YWx1ZS5tYXgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgICAgfSAvLyBXaGVuIHJhbmdlIC8gbWF4IHRodW1iIHJlYWNoZXMgdXBwZXIgbGltaXRcblxuXG4gICAgICAgIGlmIChtYXggPiB1cHBlcikge1xuICAgICAgICAgIGlmICghdGhpcy50aHVtYkRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyh0aGlzLnZhbHVlLm1pbiAtIHRoaXMudmFsdWUubWF4ICsgdXBwZXIsIHVwcGVyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyh0aGlzLnZhbHVlLm1pbiwgdXBwZXIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMudGh1bWJEcmFnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VMaW1pdHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhY3R1YWxTdGVwVmFsdWUoKSB7XG4gICAgY29uc3Qgc3RlcCA9IGZsb2F0KHRoaXMuaW5wdXRbMF0uY3VycmVudC5zdGVwKTtcbiAgICByZXR1cm4gdGhpcy5pbnB1dFswXS5jdXJyZW50LnN0ZXAgPT09IEFOWSA/IEFOWSA6IHN0ZXAgPT09IDAgfHwgaXNOYU4oc3RlcCkgPyAxIDogc3RlcDtcbiAgfSAvLyBTdGVwIHZhbHVlICh1cCBvciBkb3duKSB1c2luZyBhcnJvdyBrZXlzXG5cblxuICBzdGVwVmFsdWUoaSwga2V5KSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gKGtleSA9PT0gMzcgfHwga2V5ID09PSA0MCA/IC0xIDogMSkgKiB0aGlzLmlmVmVydGljYWxFbHNlKC0xLCAxKTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmICF0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbdGhpcy5jdXJyZW50SW5kZXgoaSldKSB7XG4gICAgICBsZXQgc3RlcCA9IHRoaXMuYWN0dWFsU3RlcFZhbHVlKCk7XG4gICAgICBzdGVwID0gc3RlcCA9PT0gQU5ZID8gMSA6IHN0ZXA7XG4gICAgICBsZXQgbWluID0gdGhpcy52YWx1ZS5taW4gKyBzdGVwICogKHRoaXMuaW5kZXgubWluID09PSBpID8gZGlyZWN0aW9uIDogMCk7XG4gICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXggKyBzdGVwICogKHRoaXMuaW5kZXgubWF4ID09PSBpID8gZGlyZWN0aW9uIDogMCk7IC8vIFdoZW4gbWluIHRodW1iIHJlYWNoZXMgdXBwZXIgbGltaXRcblxuICAgICAgaWYgKG1pbiA+IHRoaXMucmFuZ2VMaW1pdHMubWF4KSB7XG4gICAgICAgIG1pbiA9IHRoaXMucmFuZ2VMaW1pdHMubWF4O1xuICAgICAgfSAvLyBXaGVuIG1heCB0aHVtYiByZWFjaGVzIGxvd2VyIGxpbWl0XG5cblxuICAgICAgaWYgKG1heCA8IHRoaXMucmFuZ2VMaW1pdHMubWluKSB7XG4gICAgICAgIG1heCA9IHRoaXMucmFuZ2VMaW1pdHMubWluO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFZhbHVlKHtcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICAvLyBTZXQgb3B0aW9ucyB0byBkZWZhdWx0IHZhbHVlcyBpZiBub3Qgc2V0XG4gICAgdGhpcy5mYWxsYmFja1RvRGVmYXVsdCgncmFuZ2VTbGlkZURpc2FibGVkJywgZmFsc2UpO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ3RodW1ic0Rpc2FibGVkJywgW2ZhbHNlLCBmYWxzZV0pO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ29yaWVudGF0aW9uJywgJ2hvcml6b250YWwnKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdkZWZhdWx0VmFsdWUnLCBbMjUsIDc1XSk7XG4gICAgdGhpcy5mYWxsYmFja1RvRGVmYXVsdCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgdGhpcy5mYWxsYmFja1RvRGVmYXVsdCgnb25UaHVtYkRyYWdTdGFydCcsIGZhbHNlKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdvblJhbmdlRHJhZ1N0YXJ0JywgZmFsc2UpO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ29uVGh1bWJEcmFnRW5kJywgZmFsc2UpO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ29uUmFuZ2VEcmFnRW5kJywgZmFsc2UpO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ29uSW5wdXQnLCBmYWxzZSk7XG4gICAgdGhpcy5mYWxsYmFja1RvRGVmYXVsdCgnc3RlcCcsIDEpO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ21pbicsIDApO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ21heCcsIDEwMCk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSkge1xuICAgICAgdGhpcy5mYWxsYmFja1RvRGVmYXVsdCgndmFsdWUnLCBbMjUsIDc1XSk7XG4gICAgfVxuXG4gICAgdGhpcy5zYWZlTWluTWF4VmFsdWVzKCk7XG4gICAgdGhpcy5zYWZlVGh1bWJzRGlzYWJsZWRWYWx1ZXMoKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgXCJkYXRhLXRlc3RpZFwiOiBcImVsZW1lbnRcIixcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgcmVmOiB0aGlzLmVsZW1lbnQsXG4gICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeC5kZWZhdWx0KSgncmFuZ2Utc2xpZGVyJywgdGhpcy5wcm9wcy5jbGFzc05hbWUpXG4gICAgfSwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7XG4gICAgICByZWY6IHRoaXMuaW5wdXRbMF0sXG4gICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICBtaW46IHRoaXMub3B0aW9ucy5taW4sXG4gICAgICBtYXg6IHRoaXMub3B0aW9ucy5tYXgsXG4gICAgICBzdGVwOiB0aGlzLm9wdGlvbnMuc3RlcCxcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlID8gdGhpcy5vcHRpb25zLnZhbHVlWzBdIDogdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPyB0aGlzLnZhbHVlLm1pbiA6IHRoaXMub3B0aW9ucy5kZWZhdWx0VmFsdWVbMF0sXG4gICAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgICBkaXNhYmxlZDogdHJ1ZVxuICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHtcbiAgICAgIHJlZjogdGhpcy5pbnB1dFsxXSxcbiAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgIG1pbjogdGhpcy5vcHRpb25zLm1pbixcbiAgICAgIG1heDogdGhpcy5vcHRpb25zLm1heCxcbiAgICAgIHN0ZXA6IHRoaXMub3B0aW9ucy5zdGVwLFxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUgPyB0aGlzLm9wdGlvbnMudmFsdWVbMV0gOiB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA/IHRoaXMudmFsdWUubWF4IDogdGhpcy5vcHRpb25zLmRlZmF1bHRWYWx1ZVsxXSxcbiAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIGRpc2FibGVkOiB0cnVlXG4gICAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogdGhpcy50aHVtYlswXSxcbiAgICAgIHJvbGU6IFwic2xpZGVyXCIsXG4gICAgICBjbGFzc05hbWU6IFwicmFuZ2Utc2xpZGVyX190aHVtYlwiLFxuICAgICAgXCJkYXRhLWxvd2VyXCI6IHRydWVcbiAgICB9KSwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgcmVmOiB0aGlzLnRodW1iWzFdLFxuICAgICAgcm9sZTogXCJzbGlkZXJcIixcbiAgICAgIGNsYXNzTmFtZTogXCJyYW5nZS1zbGlkZXJfX3RodW1iXCIsXG4gICAgICBcImRhdGEtdXBwZXJcIjogdHJ1ZVxuICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IHRoaXMucmFuZ2UsXG4gICAgICBjbGFzc05hbWU6IFwicmFuZ2Utc2xpZGVyX19yYW5nZVwiXG4gICAgfSkpO1xuICB9XG5cbn1cblxuO1xudmFyIF9kZWZhdWx0ID0gUmFuZ2VTbGlkZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range-slider-input/dist/components/RangeSlider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range-slider-input/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-range-slider-input/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _RangeSlider = _interopRequireDefault(__webpack_require__(/*! ./components/RangeSlider */ \"(ssr)/./node_modules/react-range-slider-input/dist/components/RangeSlider.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = _RangeSlider.default;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsMENBQTBDLG1CQUFPLENBQUMsOEdBQTBCOztBQUU1RSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZXJjZS1wcm8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0L2Rpc3QvaW5kZXguanM/YTZhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9SYW5nZVNsaWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9SYW5nZVNsaWRlclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfZGVmYXVsdCA9IF9SYW5nZVNsaWRlci5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range-slider-input/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range-slider-input/dist/style.css":
/*!**************************************************************!*\
  !*** ./node_modules/react-range-slider-input/dist/style.css ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"10d9d40e0a14\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0L2Rpc3Qvc3R5bGUuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZXJjZS1wcm8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0L2Rpc3Qvc3R5bGUuY3NzPzYzMDMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxMGQ5ZDQwZTBhMTRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range-slider-input/dist/style.css\n");

/***/ })

};
;